#######################
Hibernate
#######################

-> Hibernate is an ORM (Object relation mapping) tool
-> It helps developers map Java classes to database tables and automate CRUD operations (Create, Read, Update, Delete) without writing complex SQL queries.

1. @Entity - ‚ÄúThis annotaion maps Java class to a table in the database.‚Äù
2. @Id   - Indicates the primary key column, and is mandatory to define inside entity class
---
üß© What is JPA?

**JPA (Java Persistence API)** is a *specification*, not a tool or library. Think of it as a blueprint or contract that defines:

- **What** operations should be possible for object-relational mapping (ORM)
- **How** entities should be annotated
- **What** interfaces should exist for querying and managing data

### Key traits:
- It‚Äôs part of the **Jakarta EE** (formerly Java EE) ecosystem.
- It defines annotations like `@Entity`, `@Id`, `@OneToMany`, etc.
- It provides interfaces like `EntityManager`, `Query`, and `PersistenceContext`.

But JPA **does not contain any actual implementation** ‚Äî it doesn‚Äôt persist anything by itself.

---

‚öôÔ∏è What is Hibernate?

**Hibernate** is a *concrete implementation* of the JPA specification ‚Äî and it goes beyond it.

### Hibernate does two things:
1. **Implements JPA**: It provides the actual code that makes JPA annotations and interfaces work.
2. **Adds extra features**: Hibernate has its own powerful APIs and configurations that go beyond JPA, such as:
   - Hibernate Query Language (HQL)
   - Caching strategies
   - Custom naming strategies
   - Advanced fetching and lazy loading options

---

## üîç Analogy: JPA vs Hibernate

| Concept        | JPA (Specification)         | Hibernate (Implementation)       |
|----------------|-----------------------------|----------------------------------|
| Role           | Defines *what to do*        | Defines *how to do it*           |
| Type           | Interface + annotations     | Full-fledged library             |
| Examples       | `@Entity`, `EntityManager`  | `SessionFactory`, HQL, caching   |
| Flexibility    | Vendor-neutral              | Hibernate-specific features      |

---

üß† Why use JPA at all?

- **Portability**: You can switch between providers (e.g., Hibernate ‚Üí EclipseLink) with minimal code changes.
- **Standardization**: JPA gives a consistent way to define entities and queries.
- **Abstraction**: It decouples your app from the underlying ORM engine.
---
## üß± 1. **Entity Mapping (Class-to-Table)**  
**Analogy**: Imagine a spreadsheet named ‚ÄúEmployees.‚Äù Each row is a person, and each column is a detail like name, age, or department.  
**Hibernate‚Äôs job**: It maps your Java class `Employee` to this spreadsheet so each object becomes a row in the table.
---
## üë• 2. **One-to-One Mapping**  
**Real-world example**: A person and their passport.  
- One person has exactly one passport.  
- One passport belongs to exactly one person.

**Hibernate‚Äôs job**: It links the `Person` object to the `Passport` object so when you fetch a person, you can also get their passport.
---
## üßë‚Äçü§ù‚Äçüßë 3. **One-to-Many Mapping**  
**Real-world example**: A manager and their team.  
- One manager oversees many employees.  
- Each employee reports to one manager.

**Hibernate‚Äôs job**: It connects the `Manager` object to a list of `Employee` objects. You can ask, ‚ÄúWho works under this manager?‚Äù and get the full list.

---

## üîÅ 4. **Many-to-One Mapping**  
**Real-world example**: Many books belong to one library.  
- Each book is stored in one library.  
- The library holds many books.

**Hibernate‚Äôs job**: It allows each `Book` object to reference its `Library`, so you know where it belongs.

---

## üîÑ 5. **Many-to-Many Mapping**  
**Real-world example**: Students and courses.  
- A student can enroll in multiple courses.  
- A course can have multiple students.

**Hibernate‚Äôs job**: It creates a bridge table (like a sign-up sheet) that links students to courses and vice versa.

---

## üß∫ 6. **Embedded Mapping**  
**Real-world example**: A customer and their address.  
- The address isn‚Äôt a separate entity ‚Äî it‚Äôs part of the customer‚Äôs profile.

**Hibernate‚Äôs job**: It embeds the address fields directly into the customer‚Äôs database row, like adding extra columns for city, state, and zip code.

---

## üß¨ 7. **Inheritance Mapping**  
**Real-world example**: Vehicles ‚Äî cars, bikes, and trucks all share common traits like speed and fuel type, but each has unique features.  
- You might store all vehicles in one table (single table strategy), or split them into separate tables (joined strategy).

**Hibernate‚Äôs job**: It helps you model this hierarchy so you can treat all vehicles similarly while preserving their differences.

---

## üß† What is Normalization?

**Normalization** is a database design technique that:
- Eliminates redundant data
- Ensures data integrity
- Organizes data into logical, related tables

It follows **normal forms** (1NF, 2NF, 3NF, etc.) to reduce anomalies during insert, update, or delete operations.

---

## üß© How Normalization Relates to Hibernate

Hibernate is an ORM (Object-Relational Mapping) tool. It maps Java classes to database tables. When you design your entity classes, **you should reflect normalized database design**. Here's how:

### üîπ 1NF (First Normal Form)
- **Rule**: No repeating groups or arrays in a single column.
- **Hibernate**: Use separate fields or related entities instead of storing comma-separated values.

**Example**: Instead of storing multiple phone numbers in one column, create a `PhoneNumber` entity and use a `@OneToMany` relationship.

---

### üîπ 2NF (Second Normal Form)
- **Rule**: No partial dependency on a composite key.
- **Hibernate**: Avoid embedding unrelated fields in entities that depend only on part of a composite key.

**Example**: If `OrderDetail` has a composite key (`orderId`, `productId`), don‚Äôt store customer name there ‚Äî it belongs in `Order`.

---

### üîπ 3NF (Third Normal Form)
- **Rule**: No transitive dependencies (non-key fields depending on other non-key fields).
- **Hibernate**: Break out entities like `Address`, `Department`, or `Category` into separate tables and use `@ManyToOne` or `@OneToOne`.

**Example**: Don‚Äôt store `departmentName` in `Employee` if it can be derived from a `Department` entity.

---

## üß∞ Hibernate‚Äôs Role

Hibernate doesn‚Äôt enforce normalization, but it:
- **Supports normalized design** via entity relationships (`@OneToMany`, `@ManyToOne`, etc.)
- **Maps normalized tables** to object graphs
- **Handles joins and cascades** so you don‚Äôt have to write complex SQL

---

 üöÄ What Spring Data JPA Actually Does

Spring Data JPA builds on top of the **Java Persistence API (JPA)** and integrates it seamlessly into the **Spring ecosystem**. It provides a high-level abstraction for working with relational databases using **Object-Relational Mapping (ORM)**.

### üîß Key Features:
- **Auto-generated CRUD operations**: Just extend `JpaRepository`, and you get `save()`, `findById()`, `delete()`, etc., for free.
- **Derived query methods**: Write methods like `findByEmail()` or `findByAgeGreaterThan()` ‚Äî Spring generates the SQL.
- **Pagination and sorting**: Built-in support via `Pageable` and `Sort`.
- **Custom queries**: Use JPQL or native SQL with `@Query`.
- **Auditing and lifecycle hooks**: Track who created or modified entities.
- **Works with any JPA provider**: Most commonly Hibernate.

---

## üß† How It Works Behind the Scenes

You define a **repository interface**, like this:

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findByDepartment(String department);
}
```

Spring Data JPA:
- Automatically implements this interface.
- Uses Hibernate (or another JPA provider) to execute queries.
- Injects the repository into your service layer using `@Autowired`.

---

## üß© Spring Data JPA vs JPA vs Hibernate

| Layer              | Role                          | Example |
|--------------------|-------------------------------|---------|
| **JPA**            | Specification (what to do)    | `@Entity`, `EntityManager` |
| **Hibernate**      | Implementation (how to do it) | SQL generation, caching |
| **Spring Data JPA**| Abstraction (do it for me)    | `JpaRepository`, `findByName()` |

---

## üõí Real-World Analogy

Imagine you‚Äôre building an online store:
- **JPA** is like the blueprint for how products and orders should be stored.
- **Hibernate** is the engine that actually stores and retrieves them.
- **Spring Data JPA** is your smart assistant that says, ‚ÄúJust tell me what you want ‚Äî I‚Äôll handle the rest.‚Äù

---
*
üí° What is DI (Dependency Injection)?

**Dependency Injection** is a design pattern where an object‚Äôs dependencies (like services, repositories, or utilities) are **provided to it from the outside**, rather than the object creating them itself.

### üîß In Java terms:
Instead of doing this:

```java
Service service = new Service(); // tightly coupled
```

You do this:

```java
@Autowired
Service service; // Spring injects it for you
```

---

## üè† Real-World Analogy

Imagine you're building a house:
- Without DI: The house builds its own plumbing, electricity, and furniture.
- With DI: You hire specialists (plumber, electrician, carpenter) and plug them in ‚Äî the house just uses them.

**DI = plug-and-play architecture.**

---

## ‚úÖ Why Use DI?

Here‚Äôs why DI is a game-changer:

### 1. **Loose Coupling**
- Classes don‚Äôt hardcode their dependencies.
- You can swap implementations easily (e.g., mock vs real service).

### 2. **Easier Testing**
- You can inject mock objects for unit testing.
- No need to spin up the whole app.

### 3. **Better Maintainability**
- Changes in one class don‚Äôt ripple through the whole system.
- Encourages clean, modular code.

### 4. **Reusability**
- Components can be reused in different contexts with different dependencies.

### 5. **Inversion of Control (IoC)**
- Objects don‚Äôt control how their dependencies are created ‚Äî the framework (like Spring) does.

---

## üß† In Spring Framework

Spring uses **IoC containers** to manage DI. You just annotate your classes with:

- `@Component`, `@Service`, `@Repository` ‚Üí to register beans
- `@Autowired`, `@Inject`, or constructor injection ‚Üí to inject dependencies

---
########################
What is Spring IOC? (Inversion of Control )
#########################
-> Spring IOC Container is the core of the Spring Framework.
-> It manages the lifecycle and Creation of application objects (called beans).
-> It creates, configures, and wires objects automatically based on configuration
-> Helps implement Dependency Injection (DI) easily.
-> Promotes loose coupling because your classes don‚Äôt instantiate their dependencies directly.

##################################
Bean life cycle
#####################################

Bean is Created---->Dependencies Injected (@Autowired)----->Execution(Bean is use by the application)------>Destruction of the bean
####################
Junit
#####################
-> We performe testing at the code level. This called as Unit / Whitebox testing
-> When we create Spring boot project by default we will get Junit library

Annotations in Junit
--------------------
a. @Test:
-> Will run a method as a test case and report pass or fail
-> If we have more than one @Test method in same class then we can run that in sequence
What is repository layer in spring boot?
##############################################

-> The Repository Layer provides utility methods,
-> Using this utility method we can perform database CRUD Operations
-> Example of some utility methods save(), findById(), delete(), etc.


## üè≠ What is `SessionFactory` in Hibernate?

**SessionFactory** is the central factory class in Hibernate used to create `Session` objects, which are lightweight and short-lived. It‚Äôs designed to be created once and reused throughout the application.

### üîß Key Points:
- **Heavyweight**: It‚Äôs expensive to create, so it‚Äôs typically initialized once at startup.
- **Thread-safe**: Can be shared across threads.
- **Configuration-based**: Built using Hibernate configuration (XML or annotations).
- **Creates Sessions**: Each `Session` represents a single unit of work with the database.

### üß† Real-world analogy:
Think of `SessionFactory` as a **car manufacturing plant**. It‚Äôs big, complex, and built once. Each `Session` is like a **car** ‚Äî lightweight, used for a specific trip (database operation), and then discarded.

### üîÑ In Spring Boot:
You often don‚Äôt interact with `SessionFactory` directly. Spring manages it behind the scenes using `LocalSessionFactoryBean` or via JPA‚Äôs `EntityManager` abstraction.

---

## üì¶ What is `Optional` in Java?

**Optional** is a class introduced in **Java 8** to represent a value that may or may not be present ‚Äî a safer alternative to using `null`.

### üîß Key Features:
- **Avoids NullPointerException**: You don‚Äôt need to check for `null` manually.
- **Provides methods** like:
  - `isPresent()` ‚Äî checks if a value exists
  - `ifPresent()` ‚Äî executes code if value is present
  - `orElse()` ‚Äî provides a default value
  - `map()` ‚Äî transforms the value if present

### üß† Real-world analogy:
Imagine a **gift box**:
- If the box has a gift ‚Üí you open and use it.
- If it‚Äôs empty ‚Üí you don‚Äôt panic, you just move on.

**Optional = a safe gift box for your data**.
JPQL (Java Persistence Query Language) in Hibernate
#####################################################

JPQL stands for Java Persistence Query Language. It is similar to SQL, but:
-> It works with Java entity objects, not directly with database tables.
-> It uses entity names and field/property names, not table or column names.
EXAMPLE *******************#############
@Query("select e from Employee e where e.emailId=:x")
	Optional<Employee> searchByEmail(@Param("x") String email);
	
	@Query("Select e from Employee e where e.mobile=:m")
	Optional<Employee> searchByMobile(@Param("m") String mobile);
	
	@Query("select e from Employee e where e.emailId=:x and e.mobile=:m")
	Optional<Employee> searchByEmailAndMobile( String email,@Param("m") String mobile);
Native SQl Query
##########################
 -> Raw SQL can be written with hibernate
Add this in repsoitory layer
--------------------------------
        @Query(value = "SELECT * FROM employees WHERE email_id = ?1", nativeQuery = true)
	Optional<Employee> findByEmailUsingSQl(String email);
	
	@Query(value = "SELECT * FROM employees WHERE mobile = ?1", nativeQuery = true)
	Optional<Employee> findByMobileUsingSQl(String mobile);
	
	@Query(value = "SELECT * FROM employees WHERE email_id = ?1 and mobile = ?2", nativeQuery = true)
	Optional<Employee> findByEmailandMobileUsingSQl(String email, String mobile);
 ####################   
@GeneratedValue(strategy = GenerationType.IDENTITY) by which we can seralized id by counting it is auto updated
############################


## üîç JPQL vs Native SQL in Hibernate (Spring Boot)

Here‚Äôs a clear breakdown of how they differ:

| Feature              | JPQL (Java Persistence Query Language)             | Native SQL (Raw SQL)                          |
|----------------------|----------------------------------------------------|------------------------------------------------|
| **Target**           | Works with **Java entities** and their fields      | Works with **database tables** and columns     |
| **Portability**      | **Database-independent**                           | **Database-specific**                          |
| **Syntax**           | Similar to SQL but uses entity names               | Standard SQL syntax                            |
| **Use Case**         | Ideal for most CRUD and object-based queries       | Needed for complex joins, stored procedures    |
| **Annotation**       | `@Query("SELECT e FROM Employee e")`               | `@Query(value = "SELECT * FROM employees", nativeQuery = true)` |
| **Return Type**      | Returns entity objects                             | Can return entities or raw data (Object[])     |
| **Limitations**      | Limited to JPA features                            | Full control over SQL features                 |

Sources: 

---

## üß† Real-World Analogy

Imagine you‚Äôre querying a library:
- **JPQL**: You ask for books by referencing their **Java class** (`Book`) and fields (`title`, `author`).
- **Native SQL**: You ask for books by referencing the **actual database table** (`books`) and columns (`book_title`, `book_author`).

---

## ‚úÖ When to Use What?

### Use **JPQL** when:
- You want portability across databases.
- You‚Äôre working with entity relationships (`@OneToMany`, `@ManyToOne`).
- You prefer object-oriented queries.

### Use **Native SQL** when:
- You need advanced SQL features (e.g., window functions, stored procedures).
- You‚Äôre optimizing performance with database-specific syntax.
- You‚Äôre querying non-entity tables or views.

---


## üîÑ `fetch = FetchType.EAGER`

**EAGER fetching** means:  
‚û°Ô∏è When you load an entity, **all its related entities are loaded immediately**, even if you don‚Äôt need them.

### üß† Analogy:
Imagine ordering a pizza and automatically getting fries, drinks, and dessert ‚Äî even if you just wanted the pizza.

### üß™ Example:
```java
@OneToMany(fetch = FetchType.EAGER)
private List<OrderItem> items;
```
- When you load an `Order`, Hibernate also loads all `OrderItems` right away.

### ‚ö†Ô∏è Downsides:
- Can cause **performance issues** (N+1 problem).
- Loads unnecessary data.

---

## üí§ `fetch = FetchType.LAZY`

**LAZY fetching** means:  
‚û°Ô∏è Related entities are **loaded only when accessed**, not when the parent is loaded.

### üß† Analogy:
You order a pizza, and you‚Äôll get fries only if you ask for them later.

### üß™ Example:
```java
@OneToMany(fetch = FetchType.LAZY)
private List<OrderItem> items;
```
- Hibernate loads `OrderItems` only when you call `order.getItems()`.

### ‚úÖ Benefits:
- **Better performance**.
- Loads only what you need.

### ‚ö†Ô∏è Gotcha:
- If accessed outside of a transaction (e.g., in a controller), you may get a `LazyInitializationException`.

---

## üîÅ `cascade = CascadeType.ALL`

**Cascade** means:  
‚û°Ô∏è Operations on the parent entity are **automatically applied to its child entities**.

### üß† Analogy:
If you delete a folder, all files inside it are deleted too ‚Äî you don‚Äôt need to delete each file manually.

### üß™ Example:
```java
@OneToMany(cascade = CascadeType.ALL)
private List<OrderItem> items;
```
- If you `save()` or `delete()` an `Order`, Hibernate will also `save()` or `delete()` its `OrderItems`.

### üîß Common Cascade Types:
- `PERSIST`: Save child when parent is saved.
- `MERGE`: Update child when parent is updated.
- `REMOVE`: Delete child when parent is deleted.
- `ALL`: Applies all of the above.

---

## üß© Summary Table

| Feature        | EAGER                     | LAZY                      | CascadeType.ALL               |
|----------------|---------------------------|---------------------------|-------------------------------|
| Load Timing    | Immediate                 | On-demand                 | Applies all operations        |
| Performance    | Heavy                     | Efficient                 | Depends on use case           |
| Risk           | Over-fetching             | LazyInitializationException | Unintended cascading          |
| Use Case       | Small, always-needed data | Large or optional data    | Parent-child lifecycle sync   |

---


## üîç What is `@Transactional`?

It marks a method (or class) as **transactional**, meaning:
- All database operations inside it are treated as a **single unit of work**.
- If any exception occurs, the entire transaction is **rolled back**.
- If everything succeeds, the transaction is **committed**.

---

## üß† Real-World Analogy

Imagine transferring money between two bank accounts:
- You **withdraw** from Account A
- You **deposit** into Account B

If the deposit fails, you don‚Äôt want the withdrawal to go through. You want **both steps to succeed or fail together** ‚Äî that‚Äôs a transaction.

---

## üß∞ How It Works in Hibernate

Hibernate uses transactions to manage session operations like `save()`, `update()`, and `delete()`. In Spring Boot, you typically annotate service methods:

```java
@Service
public class OrderService {

    @Transactional
    public void placeOrder(Order order) {
        orderRepository.save(order);
        paymentService.charge(order);
        inventoryService.updateStock(order);
    }
}
```

- If `charge()` or `updateStock()` fails, the entire `placeOrder()` method rolls back.
- Spring handles the transaction boundaries using AOP (Aspect-Oriented Programming).

---

## ‚úÖ Benefits of `@Transactional`

- **Atomicity**: All-or-nothing execution.
- **Consistency**: Keeps your data valid.
- **Isolation**: Prevents dirty reads and race conditions.
- **Durability**: Changes persist once committed.

---

## ‚ö†Ô∏è Common Pitfalls

- Works only on **public methods**.
- Must be called from **outside the class** (proxy-based).
- Lazy loading outside transaction scope can cause `LazyInitializationException`.

---
-> A Hibernate session is kept open for the entire method.
-> When you access post.getComments(), Hibernate can safely go to the DB and fetch the comments on demand.
-> This works perfectly with lazy loading.

Note:
-----------

| Annotation        | Definition                                                                                                               |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `@Entity`         | Declares the class as a JPA entity. It will be mapped to a table in the database.                                        |
| `@Id`             | Marks the field as the **primary key** of the entity.                                                                    |
| `@GeneratedValue` | Specifies how the primary key should be generated (e.g., auto-increment).                                                |
| `@Table`          | Specifies the table name in the database for this entity.                                                                |
| `@Column`         | Used to define column details like name, length, nullable, and uniqueness.                                               |
| `@OneToMany`      | Specifies a one-to-many relationship between two entities (e.g., one post has many comments).                            |
| `@ManyToOne`      | Specifies a many-to-one relationship (e.g., many comments belong to one post).                                           |
| `@OneToOne`       | Maps a one-to-one relationship between two entities (e.g., one person has one KYC).                                      |
| `@ManyToMany`     | Specifies a many-to-many relationship (e.g., student ‚Üî courses).                                                         |
| `@JoinColumn`     | Defines the foreign key column in the child table that maps to the parent table.                                         |
| `@Query`          | Allows writing custom JPQL or native SQL queries inside repository methods.                                              |
| `@Transactional`  | Manages the database transaction for the method or class. Automatically commits on success and rolls back on exceptions. |

#################################################################################################################################################
### üîó Unidirectional Mapping

**Definition:** Only one entity knows about the relationship.

#### Example: One-to-One (Unidirectional)
```java
@Entity
public class Person {
    @Id
    private Long id;

    @OneToOne
    private Passport passport;
}
```
- `Person` knows about `Passport`, but `Passport` has no reference back to `Person`.
- Common for simpler relationships or when reverse navigation isn't needed.

#### Characteristics:
- Easier to implement and maintain.
- Less flexible for querying from the inverse side.
- Suitable for read-only or write-once relationships.

---

### üîÅ Bidirectional Mapping

**Definition:** Both entities are aware of the relationship.

#### Example: One-to-One (Bidirectional)
```java
@Entity
public class Person {
    @Id
    private Long id;

    @OneToOne(mappedBy = "person")
    private Passport passport;
}

@Entity
public class Passport {
    @Id
    private Long id;

    @OneToOne
    @JoinColumn(name = "person_id")
    private Person person;
}
```
- `Person` and `Passport` reference each other.
- `mappedBy` indicates the owning side (the side that manages the foreign key).

#### Characteristics:
- More powerful for querying and navigation.
- Requires careful handling of cascading and synchronization.
- Ideal for complex domain models.

---

### üß† Key Differences

| Feature              | Unidirectional                          | Bidirectional                            |
|----------------------|------------------------------------------|-------------------------------------------|
| Navigation           | One-way                                 | Two-way                                   |
| Query flexibility    | Limited                                 | Enhanced                                  |
| Complexity           | Simpler                                 | More complex                              |
| Use case             | Simple relationships                    | Rich domain models                        |
| Foreign key control  | Owning side only                        | Must define `mappedBy` on inverse side    |


---

## üîç What Is Hibernate Cache?

Hibernate Cache is an **in-memory data store** that helps reduce the number of database hits by storing frequently accessed data temporarily in RAM. It's a performance booster, especially in read-heavy applications.

### ‚ö° Benefits:
- **Avoids repetitive SQL queries**: Once fetched, data is reused.
- **Reduces latency**: Faster access from memory than DB.
- **Minimizes DB load**: Fewer queries = less strain on DB.

---

## ü•á First-Level Cache (L1)

### ‚úÖ Always Enabled
- **Scope:** Per Hibernate `Session`
- **Lifetime:** Active only during the session
- **Storage:** Inside the session object

### üîÑ Behavior:
- When you call `session.get()` or `session.find()`, Hibernate first checks the L1 cache.
- If the entity is already loaded in the session, it returns from cache.
- Otherwise, it queries the DB and stores the result in L1 cache.

### üß™ Example:
```java
Session session = sessionFactory.openSession();
User user1 = session.get(User.class, 1L); // Hits DB
User user2 = session.get(User.class, 1L); // From cache
```

### üßº Eviction:
- Automatically cleared when session is closed.
- Manually via:
  ```java
  session.evict(user1); // removes specific entity
  session.clear();      // clears entire cache
  ```

### üß† Analogy:
Think of L1 cache as your **browser tab**‚Äîonce you load a page, it stays cached until you close the tab.

---

## ü•à Second-Level Cache (L2)

### üõ† Optional & Configurable
- **Scope:** Across multiple sessions
- **Lifetime:** Tied to `SessionFactory`
- **Storage:** External cache provider (Ehcache, Redis, etc.)

### üîÑ Behavior:
- When an entity is loaded, it‚Äôs stored in L2 cache.
- Future sessions can retrieve it without hitting the DB.

### üß™ Example:
```java
// User A logs in
Session sessionA = sessionFactory.openSession();
User userA = sessionA.get(User.class, 1L); // Hits DB ‚Üí stores in L2

// User B logs in
Session sessionB = sessionFactory.openSession();
User userB = sessionB.get(User.class, 1L); // Served from L2 cache
```

### üîß Configuration:
1. **Enable in `hibernate.cfg.xml` or `application.properties`:**
   ```properties
   hibernate.cache.use_second_level_cache=true
   hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
   ```

2. **Annotate Entity:**
   ```java
   @Entity
   @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
   public class User { ... }
   ```

3. **Configure Provider (e.g., `ehcache.xml`)**

---

## üß† Cache Providers

| Provider     | Description                              |
|--------------|------------------------------------------|
| **Ehcache**  | Popular, easy to configure, file-based   |
| **Caffeine** | High-performance, Java 8+                |
| **Infinispan** | Distributed, scalable, JBoss-backed     |
| **Redis**    | Networked, fast, supports clustering     |

---

## üßÆ Cache Concurrency Strategies

| Strategy                  | Use Case                                |
|---------------------------|------------------------------------------|
| `READ_ONLY`               | Immutable data (e.g., countries)         |
| `NONSTRICT_READ_WRITE`   | Rare updates, eventual consistency       |
| `READ_WRITE`             | Frequent updates, strict consistency     |
| `TRANSACTIONAL`          | Full ACID compliance (JTA required)      |

---

## üîç Query Cache (Optional)

- Caches **HQL/JPQL result sets**
- Must be explicitly enabled:
  ```properties
  hibernate.cache.use_query_cache=true
  ```
- Mark queries as cacheable:
  ```java
  Query query = session.createQuery("FROM User");
  query.setCacheable(true);
  ```

---

## ‚ö†Ô∏è Best Practices

- **Avoid caching volatile data** (e.g., sessions, tokens)
- **Use `@Cacheable` only on entities that benefit from reuse**
- **Monitor cache stats** (hit/miss ratio)
- **Evict stale data** when updates occur outside Hibernate

---

## üß† Real-World Analogy

- **L1 Cache** = Your **desk drawer**: quick access during your work session.
- **L2 Cache** = **Shared filing cabinet**: accessible to all employees (sessions), but needs coordination...





